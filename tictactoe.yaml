project: tictactoe
  idea: "Real-time multiplayer Tic-Tac-Toe web game with AI opponent, user accounts, and leaderboards"

  requirements:
    functional:
      - User registration/login system
      - Play against AI (3 difficulty levels)
      - Play against another player online
      - Real-time game updates
      - Game history and statistics
      - Global leaderboard
      - Spectate ongoing games
      - Chat during games
      - Rematch functionality
      - Responsive UI for mobile/desktop
    non-functional:
      - Response time < 200ms
      - Support 10,000 concurrent users
      - 99.9% uptime
      - HTTPS encryption
      - GDPR compliant
      - Accessible (WCAG 2.1)
      - PostgreSQL database
      - Redis for caching
      - WebSocket for real-time

  architecture:
    frontend:
      - React 18 with TypeScript
      - Redux for state management
      - Socket.io for WebSocket
      - Material-UI components
      - Axios for API calls
    backend:
      - FastAPI (Python 3.11)
      - SQLAlchemy ORM
      - Alembic migrations
      - Redis for session/game state
      - Celery for async tasks
      - JWT authentication
    infrastructure:
      - Docker containers
      - Nginx reverse proxy
      - PostgreSQL database
      - Redis cache
      - GitHub Actions CI/CD
      - AWS/Heroku deployment

  mermaid: |
    graph TB
      subgraph "Client Layer"
        RC[React Client]
        MB[Mobile Browser]
      end
      
      subgraph "Load Balancer"
        NG[Nginx]
      end
      
      subgraph "Application Layer"
        API[FastAPI Server]
        WS[WebSocket Server]
        CW[Celery Worker]
      end
      
      subgraph "Cache Layer"
        RD[(Redis)]
      end
      
      subgraph "Database Layer"
        PG[(PostgreSQL)]
      end
      
      RC --> NG
      MB --> NG
      NG --> API
      NG --> WS
      API --> RD
      API --> PG
      WS --> RD
      CW --> PG
      CW --> RD
      
      classDef client fill:#e1f5fe
      classDef server fill:#fff3e0
      classDef data fill:#f3e5f5
      class RC,MB client
      class API,WS,CW server
      class RD,PG data

  pseudocode: |
    class GameEngine:
      def __init__(self):
        self.board = [[None for _ in range(3)] for _ in range(3)]
        self.current_turn = 'X'
        self.game_status = 'active'
        self.winner = None
        
      def make_move(self, row, col, player_symbol):
        # Validate move
        if self.game_status != 'active':
          return {'success': False, 'error': 'Game not active'}
          
        if self.board[row][col] is not None:
          return {'success': False, 'error': 'Cell occupied'}
          
        if player_symbol != self.current_turn:
          return {'success': False, 'error': 'Not your turn'}
          
        # Make move
        self.board[row][col] = player_symbol
        
        # Check game state
        if self.check_winner():
          self.game_status = 'won'
          self.winner = player_symbol
          return {'success': True, 'status': 'won', 'winner': player_symbol}
          
        if self.check_draw():
          self.game_status = 'draw'
          return {'success': True, 'status': 'draw'}
          
        # Switch turn
        self.current_turn = 'O' if self.current_turn == 'X' else 'X'
        return {'success': True, 'status': 'continue'}
        
      def check_winner(self):
        # Check rows, columns, diagonals
        lines = []
        # Rows
        for row in self.board:
          lines.append(row)
        # Columns
        for col in range(3):
          lines.append([self.board[row][col] for row in range(3)])
        # Diagonals
        lines.append([self.board[i][i] for i in range(3)])
        lines.append([self.board[i][2-i] for i in range(3)])
        
        for line in lines:
          if line[0] is not None and line[0] == line[1] == line[2]:
            return True
        return False
        
      def check_draw(self):
        for row in self.board:
          if None in row:
            return False
        return True
        
    class AIPlayer:
      def __init__(self, difficulty='medium'):
        self.difficulty = difficulty
        
      def get_best_move(self, board, player_symbol):
        if self.difficulty == 'easy':
          return self.random_move(board)
        elif self.difficulty == 'medium':
          if random() < 0.5:
            return self.minimax_move(board, player_symbol)
          return self.random_move(board)
        else:  # hard
          return self.minimax_move(board, player_symbol)
          
      def minimax(self, board, depth, is_maximizing, player_symbol):
        # Terminal state checks
        if check_winner(board, player_symbol):
          return 10 - depth
        if check_winner(board, opposite(player_symbol)):
          return depth - 10
        if is_board_full(board):
          return 0
          
        if is_maximizing:
          best_score = -infinity
          for move in get_available_moves(board):
            board[move] = player_symbol
            score = minimax(board, depth + 1, False, player_symbol)
            board[move] = None
            best_score = max(score, best_score)
          return best_score
        else:
          best_score = infinity
          for move in get_available_moves(board):
            board[move] = opposite(player_symbol)
            score = minimax(board, depth + 1, True, player_symbol)
            board[move] = None
            best_score = min(score, best_score)
          return best_score

  python: |
    # models.py
    from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Boolean, JSON, Enum
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy.orm import relationship
    from datetime import datetime
    import enum
    
    Base = declarative_base()
    
    class GameStatus(enum.Enum):
        WAITING = "waiting"
        ACTIVE = "active"
        WON = "won"
        DRAW = "draw"
        ABANDONED = "abandoned"
    
    class User(Base):
        __tablename__ = "users"
        
        id = Column(Integer, primary_key=True, index=True)
        username = Column(String(50), unique=True, index=True, nullable=False)
        email = Column(String(100), unique=True, index=True, nullable=False)
        password_hash = Column(String(255), nullable=False)
        rating = Column(Integer, default=1200)
        games_played = Column(Integer, default=0)
        games_won = Column(Integer, default=0)
        games_drawn = Column(Integer, default=0)
        created_at = Column(DateTime, default=datetime.utcnow)
        is_active = Column(Boolean, default=True)
        
        # Relationships
        games_as_player1 = relationship("Game", foreign_keys="Game.player1_id", back_populates="player1")
        games_as_player2 = relationship("Game", foreign_keys="Game.player2_id", back_populates="player2")
    
    class Game(Base):
        __tablename__ = "games"
        
        id = Column(Integer, primary_key=True, index=True)
        room_code = Column(String(8), unique=True, index=True, nullable=False)
        player1_id = Column(Integer, ForeignKey("users.id"), nullable=False)
        player2_id = Column(Integer, ForeignKey("users.id"))
        is_ai_game = Column(Boolean, default=False)
        ai_difficulty = Column(String(10))
        board_state = Column(JSON, default=lambda: [[None]*3 for _ in range(3)])
        current_turn = Column(String(1), default="X")
        player1_symbol = Column(String(1), default="X")
        status = Column(Enum(GameStatus), default=GameStatus.WAITING)
        winner_id = Column(Integer, ForeignKey("users.id"))
        moves_history = Column(JSON, default=list)
        created_at = Column(DateTime, default=datetime.utcnow)
        started_at = Column(DateTime)
        completed_at = Column(DateTime)
        
        # Relationships
        player1 = relationship("User", foreign_keys=[player1_id])
        player2 = relationship("User", foreign_keys=[player2_id])
        winner = relationship("User", foreign_keys=[winner_id])
        moves = relationship("Move", back_populates="game", order_by="Move.move_number")
    
    class Move(Base):
        __tablename__ = "moves"
        
        id = Column(Integer, primary_key=True, index=True)
        game_id = Column(Integer, ForeignKey("games.id"), nullable=False)
        player_id = Column(Integer, ForeignKey("users.id"), nullable=False)
        row = Column(Integer, nullable=False)
        col = Column(Integer, nullable=False)
        symbol = Column(String(1), nullable=False)
        move_number = Column(Integer, nullable=False)
        timestamp = Column(DateTime, default=datetime.utcnow)
        
        # Relationships
        game = relationship("Game", back_populates="moves")
        player = relationship("User")
    
    # game_engine.py
    from typing import Optional, List, Tuple
    import random
    import string
    
    class TicTacToeGame:
        def __init__(self, board_state=None):
            self.board = board_state or [[None]*3 for _ in range(3)]
            self.current_turn = 'X'
            
        def make_move(self, row: int, col: int, symbol: str) -> dict:
            """Make a move and return the result."""
            if not self._is_valid_move(row, col):
                return {'success': False, 'error': 'Invalid move'}
                
            self.board[row][col] = symbol
            
            if self._check_winner():
                return {'success': True, 'status': 'won', 'winner': symbol}
            
            if self._check_draw():
                return {'success': True, 'status': 'draw'}
                
            self.current_turn = 'O' if self.current_turn == 'X' else 'X'
            return {'success': True, 'status': 'continue'}
            
        def _is_valid_move(self, row: int, col: int) -> bool:
            return (0 <= row < 3 and 0 <= col < 3 and 
                   self.board[row][col] is None)
            
        def _check_winner(self) -> bool:
            # Check rows
            for row in self.board:
                if row[0] and row[0] == row[1] == row[2]:
                    return True
                    
            # Check columns
            for col in range(3):
                if (self.board[0][col] and 
                    self.board[0][col] == self.board[1][col] == self.board[2][col]):
                    return True
                    
            # Check diagonals
            if (self.board[0][0] and 
                self.board[0][0] == self.board[1][1] == self.board[2][2]):
                return True
                
            if (self.board[0][2] and 
                self.board[0][2] == self.board[1][1] == self.board[2][0]):
                return True
                
            return False
            
        def _check_draw(self) -> bool:
            for row in self.board:
                if None in row:
                    return False
            return True
            
        def get_available_moves(self) -> List[Tuple[int, int]]:
            moves = []
            for i in range(3):
                for j in range(3):
                    if self.board[i][j] is None:
                        moves.append((i, j))
            return moves
    
    class AIPlayer:
        def __init__(self, difficulty='medium', symbol='O'):
            self.difficulty = difficulty
            self.symbol = symbol
            self.opponent = 'X' if symbol == 'O' else 'O'
            
        def get_move(self, board: List[List]) -> Tuple[int, int]:
            if self.difficulty == 'easy':
                return self._random_move(board)
            elif self.difficulty == 'medium':
                if random.random() < 0.7:
                    return self._best_move(board)
                return self._random_move(board)
            else:  # hard
                return self._best_move(board)
                
        def _random_move(self, board: List[List]) -> Tuple[int, int]:
            available = []
            for i in range(3):
                for j in range(3):
                    if board[i][j] is None:
                        available.append((i, j))
            return random.choice(available) if available else (-1, -1)
            
        def _best_move(self, board: List[List]) -> Tuple[int, int]:
            best_score = float('-inf')
            best_move = (-1, -1)
            
            for i in range(3):
                for j in range(3):
                    if board[i][j] is None:
                        board[i][j] = self.symbol
                        score = self._minimax(board, 0, False)
                        board[i][j] = None
                        
                        if score > best_score:
                            best_score = score
                            best_move = (i, j)
                            
            return best_move
            
        def _minimax(self, board: List[List], depth: int, is_maximizing: bool) -> int:
            winner = self._check_winner(board)
            
            if winner == self.symbol:
                return 10 - depth
            elif winner == self.opponent:
                return depth - 10
            elif self._is_draw(board):
                return 0
                
            if is_maximizing:
                best_score = float('-inf')
                for i in range(3):
                    for j in range(3):
                        if board[i][j] is None:
                            board[i][j] = self.symbol
                            score = self._minimax(board, depth + 1, False)
                            board[i][j] = None
                            best_score = max(score, best_score)
                return best_score
            else:
                best_score = float('inf')
                for i in range(3):
                    for j in range(3):
                        if board[i][j] is None:
                            board[i][j] = self.opponent
                            score = self._minimax(board, depth + 1, True)
                            board[i][j] = None
                            best_score = min(score, best_score)
                return best_score
                
        def _check_winner(self, board: List[List]) -> Optional[str]:
            # Check rows, columns, diagonals
            for row in board:
                if row[0] and row[0] == row[1] == row[2]:
                    return row[0]
                    
            for col in range(3):
                if board[0][col] and board[0][col] == board[1][col] == board[2][col]:
                    return board[0][col]
                    
            if board[0][0] and board[0][0] == board[1][1] == board[2][2]:
                return board[0][0]
                
            if board[0][2] and board[0][2] == board[1][1] == board[2][0]:
                return board[0][2]
                
            return None
            
        def _is_draw(self, board: List[List]) -> bool:
            for row in board:
                if None in row:
                    return False
            return True
    
    def generate_room_code() -> str:
        """Generate a unique room code."""
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

  tests: |
    # test_game_engine.py
    import pytest
    from game_engine import TicTacToeGame, AIPlayer
    
    class TestTicTacToeGame:
        def test_initialization(self):
            game = TicTacToeGame()
            assert game.board == [[None]*3 for _ in range(3)]
            assert game.current_turn == 'X'
            
        def test_valid_move(self):
            game = TicTacToeGame()
            result = game.make_move(0, 0, 'X')
            assert result['success'] == True
            assert result['status'] == 'continue'
            assert game.board[0][0] == 'X'
            assert game.current_turn == 'O'
            
        def test_invalid_move_occupied(self):
            game = TicTacToeGame()
            game.make_move(0, 0, 'X')
            result = game.make_move(0, 0, 'O')
            assert result['success'] == False
            assert 'error' in result
            
        def test_win_horizontal(self):
            game = TicTacToeGame()
            game.board = [['X', 'X', None],
                         [None, None, None],
                         [None, None, None]]
            result = game.make_move(0, 2, 'X')
            assert result['status'] == 'won'
            assert result['winner'] == 'X'
            
        def test_win_vertical(self):
            game = TicTacToeGame()
            game.board = [['X', None, None],
                         ['X', None, None],
                         [None, None, None]]
            result = game.make_move(2, 0, 'X')
            assert result['status'] == 'won'
            
        def test_win_diagonal(self):
            game = TicTacToeGame()
            game.board = [['X', None, None],
                         [None, 'X', None],
                         [None, None, None]]
            result = game.make_move(2, 2, 'X')
            assert result['status'] == 'won'
            
        def test_draw(self):
            game = TicTacToeGame()
            game.board = [['X', 'O', 'X'],
                         ['X', 'O', 'O'],
                         ['O', 'X', None]]
            result = game.make_move(2, 2, 'X')
            assert result['status'] == 'draw'
            
        def test_available_moves(self):
            game = TicTacToeGame()
            game.board = [['X', None, 'O'],
                         [None, 'X', None],
                         ['O', None, None]]
            moves = game.get_available_moves()
            assert len(moves) == 5
            assert (0, 1) in moves
            assert (1, 0) in moves
    
    class TestAIPlayer:
        def test_initialization(self):
            ai = AIPlayer(difficulty='hard', symbol='O')
            assert ai.difficulty == 'hard'
            assert ai.symbol == 'O'
            assert ai.opponent == 'X'
            
        def test_random_move(self):
            ai = AIPlayer(difficulty='easy')
            board = [[None, 'X', None],
                     ['O', None, None],
                     [None, None, 'X']]
            move = ai._random_move(board)
            assert board[move[0]][move[1]] is None
            
        def test_block_win(self):
            ai = AIPlayer(difficulty='hard', symbol='O')
            board = [['X', 'X', None],
                     [None, None, None],
                     [None, None, None]]
            move = ai._best_move(board)
            assert move == (0, 2)  # Block X from winning
            
        def test_take_win(self):
            ai = AIPlayer(difficulty='hard', symbol='O')
            board = [['O', 'O', None],
                     ['X', 'X', None],
                     [None, None, None]]
            move = ai._best_move(board)
            assert move == (0, 2)  # Take the win
    
    # test_api.py
    import pytest
    from fastapi.testclient import TestClient
    from main import app
    from database import Base, engine
    
    client = TestClient(app)
    
    @pytest.fixture(autouse=True)
    def setup_database():
        Base.metadata.create_all(bind=engine)
        yield
        Base.metadata.drop_all(bind=engine)
    
    class TestUserEndpoints:
        def test_register_user(self):
            response = client.post("/api/register", json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "testpass123"
            })
            assert response.status_code == 201
            assert "id" in response.json()
            
        def test_login_user(self):
            # Register first
            client.post("/api/register", json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "testpass123"
            })
            # Login
            response = client.post("/api/login", json={
                "username": "testuser",
                "password": "testpass123"
            })
            assert response.status_code == 200
            assert "access_token" in response.json()
            
    class TestGameEndpoints:
        def test_create_game(self, auth_headers):
            response = client.post("/api/games", 
                                  json={"game_type": "ai", "difficulty": "medium"},
                                  headers=auth_headers)
            assert response.status_code == 201
            assert "room_code" in response.json()
            
        def test_make_move(self, auth_headers, game_id):
            response = client.post(f"/api/games/{game_id}/move",
                                  json={"row": 0, "col": 0},
                                  headers=auth_headers)
            assert response.status_code == 200
            assert response.json()["success"] == True

  api: |
    # main.py
    from fastapi import FastAPI, HTTPException, Depends, WebSocket, WebSocketDisconnect, status
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
    from sqlalchemy.orm import Session
    from typing import Dict, List, Optional
    from datetime import datetime, timedelta
    import json
    import asyncio
    
    from database import get_db, engine
    from models import Base, User, Game, Move, GameStatus
    from game_engine import TicTacToeGame, AIPlayer, generate_room_code
    from schemas import (UserCreate, UserResponse, GameCreate, GameResponse, 
                        MoveCreate, MoveResponse, Token, LeaderboardResponse)
    from auth import create_access_token, verify_password, get_password_hash, get_current_user
    
    Base.metadata.create_all(bind=engine)
    
    app = FastAPI(title="TicTacToe API", version="1.0.0")
    
    # CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["http://localhost:3000"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # WebSocket connection manager
    class ConnectionManager:
        def __init__(self):
            self.active_connections: Dict[str, List[WebSocket]] = {}
            
        async def connect(self, websocket: WebSocket, room_code: str):
            await websocket.accept()
            if room_code not in self.active_connections:
                self.active_connections[room_code] = []
            self.active_connections[room_code].append(websocket)
            
        def disconnect(self, websocket: WebSocket, room_code: str):
            if room_code in self.active_connections:
                self.active_connections[room_code].remove(websocket)
                if not self.active_connections[room_code]:
                    del self.active_connections[room_code]
                    
        async def broadcast_to_room(self, room_code: str, message: dict):
            if room_code in self.active_connections:
                for connection in self.active_connections[room_code]:
                    await connection.send_json(message)
                    
        async def send_personal_message(self, websocket: WebSocket, message: dict):
            await websocket.send_json(message)
    
    manager = ConnectionManager()
    
    # Authentication endpoints
    @app.post("/api/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
    async def register(user: UserCreate, db: Session = Depends(get_db)):
        # Check if user exists
        db_user = db.query(User).filter(
            (User.username == user.username) | (User.email == user.email)
        ).first()
        
        if db_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username or email already registered"
            )
        
        # Create new user
        hashed_password = get_password_hash(user.password)
        db_user = User(
            username=user.username,
            email=user.email,
            password_hash=hashed_password
        )
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        
        return db_user
    
    @app.post("/api/login", response_model=Token)
    async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
        user = db.query(User).filter(User.username == form_data.username).first()
        
        if not user or not verify_password(form_data.password, user.password_hash):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token = create_access_token(data={"sub": user.username})
        return {"access_token": access_token, "token_type": "bearer"}
    
    # Game endpoints
    @app.post("/api/games", response_model=GameResponse, status_code=status.HTTP_201_CREATED)
    async def create_game(
        game_data: GameCreate,
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        room_code = generate_room_code()
        
        # Ensure unique room code
        while db.query(Game).filter(Game.room_code == room_code).first():
            room_code = generate_room_code()
        
        db_game = Game(
            room_code=room_code,
            player1_id=current_user.id,
            is_ai_game=game_data.game_type == "ai",
            ai_difficulty=game_data.difficulty if game_data.game_type == "ai" else None,
            status=GameStatus.ACTIVE if game_data.game_type == "ai" else GameStatus.WAITING
        )
        
        db.add(db_game)
        db.commit()
        db.refresh(db_game)
        
        return db_game
    
    @app.post("/api/games/join/{room_code}", response_model=GameResponse)
    async def join_game(
        room_code: str,
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        game = db.query(Game).filter(Game.room_code == room_code).first()
        
        if not game:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Game not found"
            )
        
        if game.status != GameStatus.WAITING:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Game is not available to join"
            )
        
        if game.player1_id == current_user.id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="You cannot join your own game"
            )
        
        game.player2_id = current_user.id
        game.status = GameStatus.ACTIVE
        game.started_at = datetime.utcnow()
        
        db.commit()
        db.refresh(game)
        
        # Notify player 1 via WebSocket
        await manager.broadcast_to_room(room_code, {
            "type": "player_joined",
            "player2": current_user.username
        })
        
        return game
    
    @app.post("/api/games/{game_id}/move", response_model=MoveResponse)
    async def make_move(
        game_id: int,
        move_data: MoveCreate,
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        game = db.query(Game).filter(Game.id == game_id).first()
        
        if not game:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Game not found"
            )
        
        if game.status != GameStatus.ACTIVE:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Game is not active"
            )
        
        # Determine player symbol
        if current_user.id == game.player1_id:
            player_symbol = game.player1_symbol
        elif current_user.id == game.player2_id:
            player_symbol = 'O' if game.player1_symbol == 'X' else 'X'
        else:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="You are not a player in this game"
            )
        
        # Check if it's the player's turn
        if player_symbol != game.current_turn:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Not your turn"
            )
        
        # Make the move
        game_engine = TicTacToeGame(game.board_state)
        result = game_engine.make_move(move_data.row, move_data.col, player_symbol)
        
        if not result['success']:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=result['error']
            )
        
        # Update game state
        game.board_state = game_engine.board
        game.current_turn = game_engine.current_turn
        
        # Save move to database
        move_number = len(game.moves) + 1
        db_move = Move(
            game_id=game.id,
            player_id=current_user.id,
            row=move_data.row,
            col=move_data.col,
            symbol=player_symbol,
            move_number=move_number
        )
        db.add(db_move)
        
        # Check game result
        if result['status'] == 'won':
            game.status = GameStatus.WON
            game.winner_id = current_user.id
            game.completed_at = datetime.utcnow()
            
            # Update player statistics
            current_user.games_played += 1
            current_user.games_won += 1
            current_user.rating += 25
            
            opponent_id = game.player2_id if current_user.id == game.player1_id else game.player1_id
            if opponent_id and not game.is_ai_game:
                opponent = db.query(User).filter(User.id == opponent_id).first()
                opponent.games_played += 1
                opponent.rating -= 25
                
        elif result['status'] == 'draw':
            game.status = GameStatus.DRAW
            game.completed_at = datetime.utcnow()
            
            # Update player statistics
            current_user.games_played += 1
            current_user.games_drawn += 1
            
            if game.player2_id and not game.is_ai_game:
                opponent = db.query(User).filter(User.id == game.player2_id).first()
                opponent.games_played += 1
                opponent.games_drawn += 1
        
        db.commit()
        
        # Broadcast move to room
        await manager.broadcast_to_room(game.room_code, {
            "type": "move",
            "row": move_data.row,
            "col": move_data.col,
            "symbol": player_symbol,
            "nextTurn": game.current_turn,
            "status": result['status'],
            "winner": result.get('winner')
        })
        
        # If AI game and game continues, make AI move
        if game.is_ai_game and result['status'] == 'continue':
            ai = AIPlayer(difficulty=game.ai_difficulty, symbol='O')
            ai_row, ai_col = ai.get_move(game.board_state)
            
            if ai_row != -1:
                # Make AI move
                ai_result = game_engine.make_move(ai_row, ai_col, 'O')
                game.board_state = game_engine.board
                game.current_turn = game_engine.current_turn
                
                # Save AI move
                ai_move = Move(
                    game_id=game.id,
                    player_id=None,  # AI has no user ID
                    row=ai_row,
                    col=ai_col,
                    symbol='O',
                    move_number=move_number + 1
                )
                db.add(ai_move)
                
                # Check AI move result
                if ai_result['status'] == 'won':
                    game.status = GameStatus.WON
                    game.completed_at = datetime.utcnow()
                    current_user.games_played += 1
                elif ai_result['status'] == 'draw':
                    game.status = GameStatus.DRAW
                    game.completed_at = datetime.utcnow()
                    current_user.games_played += 1
                    current_user.games_drawn += 1
                
                db.commit()
                
                # Broadcast AI move
                await manager.broadcast_to_room(game.room_code, {
                    "type": "move",
                    "row": ai_row,
                    "col": ai_col,
                    "symbol": 'O',
                    "nextTurn": game.current_turn,
                    "status": ai_result['status'],
                    "winner": ai_result.get('winner')
                })
        
        return {
            "success": True,
            "board_state": game.board_state,
            "status": result['status'],
            "winner": result.get('winner')
        }
    
    @app.get("/api/games/{game_id}", response_model=GameResponse)
    async def get_game(
        game_id: int,
        current_user: User = Depends(get_current_user),
        db: Session = Depends(get_db)
    ):
        game = db.query(Game).filter(Game.id == game_id).first()
        
        if not game:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Game not found"
            )
        
        return game
    
    @app.get("/api/leaderboard", response_model=List[LeaderboardResponse])
    async def get_leaderboard(
        limit: int = 10,
        db: Session = Depends(get_db)
    ):
        users = db.query(User).order_by(User.rating.desc()).limit(limit).all()
        
        return [
            {
                "username": user.username,
                "rating": user.rating,
                "games_played": user.games_played,
                "games_won": user.games_won,
                "games_drawn": user.games_drawn,
                "win_rate": (user.games_won / user.games_played * 100) if user.games_played > 0 else 0
            }
            for user in users
        ]
    
    # WebSocket endpoint
    @app.websocket("/ws/{room_code}")
    async def websocket_endpoint(websocket: WebSocket, room_code: str):
        await manager.connect(websocket, room_code)
        try:
            while True:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                # Handle different message types
                if message["type"] == "chat":
                    await manager.broadcast_to_room(room_code, {
                        "type": "chat",
                        "username": message["username"],
                        "message": message["message"],
                        "timestamp": datetime.utcnow().isoformat()
                    })
                elif message["type"] == "typing":
                    await manager.broadcast_to_room(room_code, {
                        "type": "typing",
                        "username": message["username"]
                    })
                    
        except WebSocketDisconnect:
            manager.disconnect(websocket, room_code)
            await manager.broadcast_to_room(room_code, {
                "type": "player_disconnected"
            })

  database: |
    -- PostgreSQL schema
    CREATE DATABASE tictactoe;
    
    CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        rating INTEGER DEFAULT 1200,
        games_played INTEGER DEFAULT 0,
        games_won INTEGER DEFAULT 0,
        games_drawn INTEGER DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT true
    );
    
    CREATE TYPE game_status AS ENUM ('waiting', 'active', 'won', 'draw', 'abandoned');
    
    CREATE TABLE games (
        id SERIAL PRIMARY KEY,
        room_code VARCHAR(8) UNIQUE NOT NULL,
        player1_id INTEGER REFERENCES users(id) NOT NULL,
        player2_id INTEGER REFERENCES users(id),
        is_ai_game BOOLEAN DEFAULT false,
        ai_difficulty VARCHAR(10),
        board_state JSONB DEFAULT '[[null,null,null],[null,null,null],[null,null,null]]',
        current_turn CHAR(1) DEFAULT 'X',
        player1_symbol CHAR(1) DEFAULT 'X',
        status game_status DEFAULT 'waiting',
        winner_id INTEGER REFERENCES users(id),
        moves_history JSONB DEFAULT '[]',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        started_at TIMESTAMP,
        completed_at TIMESTAMP
    );
    
    CREATE TABLE moves (
        id SERIAL PRIMARY KEY,
        game_id INTEGER REFERENCES games(id) NOT NULL,
        player_id INTEGER REFERENCES users(id),
        row INTEGER NOT NULL CHECK (row >= 0 AND row < 3),
        col INTEGER NOT NULL CHECK (col >= 0 AND col < 3),
        symbol CHAR(1) NOT NULL CHECK (symbol IN ('X', 'O')),
        move_number INTEGER NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    -- Indexes for performance
    CREATE INDEX idx_games_room_code ON games(room_code);
    CREATE INDEX idx_games_status ON games(status);
    CREATE INDEX idx_games_player1 ON games(player1_id);
    CREATE INDEX idx_games_player2 ON games(player2_id);
    CREATE INDEX idx_moves_game ON moves(game_id);
    CREATE INDEX idx_users_rating ON users(rating DESC);

  deployment: |
    # docker-compose.yml
    version: '3.8'
    
    services:
      postgres:
        image: postgres:14
        environment:
          POSTGRES_DB: tictactoe
          POSTGRES_USER: tictactoe_user
          POSTGRES_PASSWORD: ${DB_PASSWORD}
        volumes:
          - postgres_data:/var/lib/postgresql/data
        ports:
          - "5432:5432"
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U tictactoe_user"]
          interval: 10s
          timeout: 5s
          retries: 5
      
      redis:
        image: redis:7-alpine
        ports:
          - "6379:6379"
        healthcheck:
          test: ["CMD", "redis-cli", "ping"]
          interval: 10s
          timeout: 5s
          retries: 5
      
      backend:
        build:
          context: ./backend
          dockerfile: Dockerfile
        environment:
          DATABASE_URL: postgresql://tictactoe_user:${DB_PASSWORD}@postgres/tictactoe
          REDIS_URL: redis://redis:6379
          SECRET_KEY: ${SECRET_KEY}
          CORS_ORIGINS: ${CORS_ORIGINS}
        ports:
          - "8000:8000"
        depends_on:
          postgres:
            condition: service_healthy
          redis:
            condition: service_healthy
        volumes:
          - ./backend:/app
        command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
      
      frontend:
        build:
          context: ./frontend
          dockerfile: Dockerfile
        environment:
          REACT_APP_API_URL: ${API_URL}
          REACT_APP_WS_URL: ${WS_URL}
        ports:
          - "3000:80"
        depends_on:
          - backend
      
      nginx:
        image: nginx:alpine
        volumes:
          - ./nginx.conf:/etc/nginx/nginx.conf:ro
        ports:
          - "80:80"
          - "443:443"
        depends_on:
          - backend
          - frontend
    
    volumes:
      postgres_data:
    
    ---
    # Dockerfile (backend)
    FROM python:3.11-slim
    
    WORKDIR /app
    
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    COPY . .
    
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
    
    ---
    # Dockerfile (frontend)
    FROM node:18-alpine as build
    
    WORKDIR /app
    
    COPY package*.json ./
    RUN npm ci
    
    COPY . .
    RUN npm run build
    
    FROM nginx:alpine
    COPY --from=build /app/build /usr/share/nginx/html
    COPY nginx.conf /etc/nginx/conf.d/default.conf
    
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]
    
    ---
    # .github/workflows/ci-cd.yml
    name: CI/CD Pipeline
    
    on:
      push:
        branches: [main, develop]
      pull_request:
        branches: [main]
    
    jobs:
      test:
        runs-on: ubuntu-latest
        
        services:
          postgres:
            image: postgres:14
            env:
              POSTGRES_PASSWORD: testpass
              POSTGRES_DB: testdb
            options: >-
              --health-cmd pg_isready
              --health-interval 10s
              --health-timeout 5s
              --health-retries 5
        
        steps:
        - uses: actions/checkout@v3
        
        - name: Set up Python
          uses: actions/setup-python@v4
          with:
            python-version: '3.11'
        
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r backend/requirements.txt
            pip install pytest pytest-cov
        
        - name: Run tests
          env:
            DATABASE_URL: postgresql://postgres:testpass@localhost/testdb
          run: |
            cd backend
            pytest --cov=./ --cov-report=xml
        
        - name: Upload coverage
          uses: codecov/codecov-action@v3
          with:
            file: ./backend/coverage.xml
      
      build-and-push:
        needs: test
        runs-on: ubuntu-latest
        if: github.ref == 'refs/heads/main'
        
        steps:
        - uses: actions/checkout@v3
        
        - name: Set up Docker Buildx
          uses: docker/setup-buildx-action@v2
        
        - name: Login to DockerHub
          uses: docker/login-action@v2
          with:
            username: ${{ secrets.DOCKER_USERNAME }}
            password: ${{ secrets.DOCKER_PASSWORD }}
        
        - name: Build and push backend
          uses: docker/build-push-action@v4
          with:
            context: ./backend
            push: true
            tags: ${{ secrets.DOCKER_USERNAME }}/tictactoe-backend:latest
        
        - name: Build and push frontend
          uses: docker/build-push-action@v4
          with:
            context: ./frontend
            push: true
            tags: ${{ secrets.DOCKER_USERNAME }}/tictactoe-frontend:latest
      
      deploy:
        needs: build-and-push
        runs-on: ubuntu-latest
        if: github.ref == 'refs/heads/main'
        
        steps:
        - name: Deploy to server
          uses: appleboy/ssh-action@v0.1.5
          with:
            host: ${{ secrets.HOST }}
            username: ${{ secrets.USERNAME }}
            key: ${{ secrets.SSH_KEY }}
            script: |
              cd /app/tictactoe
              docker-compose pull
              docker-compose up -d --no-deps --build

  json: |
    {
      "api_examples": {
        "register": {
          "request": {
            "method": "POST",
            "url": "/api/register",
            "body": {
              "username": "player1",
              "email": "player1@example.com",
              "password": "securepass123"
            }
          },
          "response": {
            "id": 1,
            "username": "player1",
            "email": "player1@example.com",
            "rating": 1200,
            "games_played": 0,
            "games_won": 0,
            "games_drawn": 0,
            "created_at": "2024-01-15T10:30:00Z"
          }
        },
        "create_game": {
          "request": {
            "method": "POST",
            "url": "/api/games",
            "headers": {
              "Authorization": "Bearer <token>"
            },
            "body": {
              "game_type": "multiplayer"
            }
          },
          "response": {
            "id": 1,
            "room_code": "ABC12345",
            "player1_id": 1,
            "player2_id": null,
            "board_state": [[null,null,null],[null,null,null],[null,null,null]],
            "current_turn": "X",
            "status": "waiting",
            "created_at": "2024-01-15T10:35:00Z"
          }
        },
        "make_move": {
          "request": {
            "method": "POST",
            "url": "/api/games/1/move",
            "headers": {
              "Authorization": "Bearer <token>"
            },
            "body": {
              "row": 1,
              "col": 1
            }
          },
          "response": {
            "success": true,
            "board_state": [[null,null,null],[null,"X",null],[null,null,null]],
            "status": "continue",
            "winner": null
          }
        },
        "websocket_message": {
          "connect": "ws://localhost:8000/ws/ABC12345",
          "send": {
            "type": "chat",
            "username": "player1",
            "message": "Good game!"
          },
          "receive": {
            "type": "move",
            "row": 0,
            "col": 0,
            "symbol": "X",
            "nextTurn": "O",
            "status": "continue",
            "winner": null
          }
        },
        "leaderboard": {
          "request": {
            "method": "GET",
            "url": "/api/leaderboard?limit=5"
          },
          "response": [
            {
              "username": "champion",
              "rating": 1450,
              "games_played": 50,
              "games_won": 35,
              "games_drawn": 10,
              "win_rate": 70.0
            },
            {
              "username": "player2",
              "rating": 1380,
              "games_played": 30,
              "games_won": 20,
              "games_drawn": 5,
              "win_rate": 66.67
            }
          ]
        }
      },
      "game_states": {
        "empty_board": [[null,null,null],[null,null,null],[null,null,null]],
        "in_progress": [["X",null,"O"],[null,"X",null],["O",null,null]],
        "x_wins": [["X","O","X"],["O","X","O"],["O","X","X"]],
        "draw": [["X","O","X"],["X","O","O"],["O","X","X"]]
      },
      "configuration": {
        "development": {
          "api_url": "http://localhost:8000",
          "ws_url": "ws://localhost:8000",
          "database": "sqlite:///./tictactoe.db"
        },
        "production": {
          "api_url": "https://api.tictactoe.com",
          "ws_url": "wss://api.tictactoe.com",
          "database": "postgresql://user:pass@db.tictactoe.com/tictactoe"
        }
      }
    }
This complete implementation includes:

Full-stack architecture with React frontend and FastAPI backend
Real-time multiplayer using WebSockets
AI opponent with difficulty levels using minimax algorithm
User authentication with JWT tokens
PostgreSQL database with proper schema and relationships
Comprehensive testing for game logic and API
Docker deployment with compose configuration
CI/CD pipeline with GitHub Actions
Production-ready features like leaderboards, game history, and chat
The system is scalable, maintainable, and ready for deployment to cloud platforms like AWS, Heroku, or DigitalOcean.
